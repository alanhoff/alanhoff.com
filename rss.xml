<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Alan Hoffmeister]]></title><description><![CDATA[Alan Hoffmeister]]></description><link>https://alanhoff.com</link><generator>metalsmith-feed</generator><lastBuildDate>Tue, 27 Jan 2015 19:07:16 GMT</lastBuildDate><atom:link href="https://alanhoff.com/rss.xml" rel="self" type="application/rss+xml"/><author><![CDATA[Alan Hoffmeister]]></author><item><title><![CDATA[Compilando o Node.js para sistemas embarcados]]></title><description><![CDATA[
Você sabia que o Node.js pode rodar normalmente dentro da sua Raspbepry Pi ou
da sua BeagleBoard? O único problema é que não é tão fácil quanto os
monoclicadores de "Next, Next, Finish" imaginam.
<!--more-->

Por algum motivo obscuro e desconhecido por minha pessoa, a Joyent não gosta
de disponibilizar binários pré compilados do Node.js para sistemas embarcados,
igual ela faz para o Linux, Windows, Mac e SunOS.. Isso é uma pena pois
facilitaria muito a vida das pessoas que querem se aventurar no mundo dos
sistemas embarcados e construir sistemas dentro de placas do tamanho de um
cartão de crédito.

Muitos tutoriais e recursos que encontramos na internet estão desatualizados
e não são claros quanto ao que fazemos durante o percurso da compilação
deixando aquele ar de "wtf are those magic words", por isso resolvi comentar
um pouco sobre o assunto.

![](/assets/img/posts/wtf.gif)

### Antes de começar

Para que tudo funcione bem precisamos ter certeza que temos todos os requisitos
abaixo:

* Uma placa com processador capaz de interpretar o conjunto de instruções ARMv7
* Ubuntu 14.10 (achou que iríamos compilar algo no Windows?)
* Boa vontade e paciência
* Pacotes `build-essential`, `curl` e `xz-util` instalado no seu sistema.

Caso você não esteja rodando esta versão do Linux, pode tentar com qualquer
outra, tenho certeza que não será complicado. Se tudo der errado, tente
instalar o Ubuntu 14.10 em uma VM.

### O toolchain

Primeiramente crie uma pasta para servir de diretório de trabalho, com o comando
`mkdir node4arm && cd node4arm`. A primeira coisa que precisamos ter em mãos
é o compilador compatível com o processador da placa que usaremos, no meu caso
vou precisar de um compilador com a interface binária (ABI) que compile
instruções para processadores da família ARMv7, então faremos o download.

```bash
curl -s url -s http://archlinuxarm.org/builder/xtools/x-tools7h.tar.xz | tar xvJf -
```

Este comando irá criar uma pasta chamada x-tools7h, dentro da qual exite o
compilador e as ferramentas que precisamos para transformar o nosso código C/++
em instruções binárias.

**Dica:** se o conjunto de informações do processador da sua placa não for ARMv7
ou se você está em dúvida acesse sua placa e em um terminal digite
`less /proc/cpuinfo`, este comando vai mostrar na sua tela informações
importantes sobre o processador da sua placa, depois basta visitar
http://archlinuxarm.org/builder/xtools e baixar a versão correspondente ao seu
processador.

### O Node.js

O próximo passo é baixar o código fonte do Node.js e descompactá-lo, utilize
este comando:

```bash
curl -s http://nodejs.org/dist/v0.10.36/node-v0.10.36.tar.gz | tar zxvf -
```

Usando o comando `cd node-v0.10.36`, entre na pasta para iniciar a configuração
e a compilação.

### Compilando

O último passo é setar algumas variáveis de ambiente, algumas flags e compilar
o binário! Utilize o script abaixo para isso

```bash
# Dizemos onde estão nossos compiladores
export PATH="$(pwd)/../x-tools7h/arm-unknown-linux-gnueabihf/bin:$PATH"
export TOOL_PREFIX="arm-unknown-linux-gnueabihf"
export AR="${TOOL_PREFIX}-ar"
export CC="${TOOL_PREFIX}-gcc"
export CXX="${TOOL_PREFIX}-g++"
export LINK="${TOOL_PREFIX}-g++"
export RANLIB="${TOOL_PREFIX}-ranlib"

# Configuramos o binário que queremos compilar para
# que seja para sistemas com hard float point e sem snapshot
./configure --with-arm-float-abi hard --without-snapshot

# Compilar!
make
```

Note que usamos algumas flags para a configuração da compilação,
`--with-arm-float-abi hard` serve para setarmos a compilação para usar a ABI com
hard float point, enquanto `--whitout-snapshot` serve para desabilitar o serviço
de snapshots da V8, que não é compatível com cross compiling.

Depois de rodar este script, o seu binário estará localizado na pasta
`./out/Release`.

### Bônus

Para automatizar o processo criei um script que pode ser encontrado [aqui][0],
basta rodá-lo em qualquer pasta vazia com permissões de escrita, ele já faz
o download da última versão do Node.js e compila o source com todos os cores
disponíveis na sua máquina. Para executar o script basta executar:

```bash
curl -s https://alanhoff.com/assets/etc/node-latest-armv7-generic.sh | bash
```

[0]: https://alanhoff.com/assets/etc/node-latest-armv7-generic.sh
]]></description><guid isPermaLink="false">Compilando o Node.js para sistemas embarcados</guid><dc:creator><![CDATA[Alan Hoffmeister]]></dc:creator><pubDate>Tue, 27 Jan 2015 21:00:00 GMT</pubDate></item><item><title><![CDATA[Criando executáveis com Node.js]]></title><description><![CDATA[
Quem nunca teve a vontade de criar um executável para distribuir em outras
máquinas e clientes, usando o Node.js? Hoje vamos falar um pouco sobre como
criar um arquivo único contendo o seu código junto com o Node.js.
<!--more-->

Dica simples e rápida para quem deseja criar aquele `arquivo.exe` ou executar um
`./hello-world` no terminar sem precisar instalar o Node.js.

A distribuição do Node.js já vem pré configurada para ser distribuída juntamente
com arquivos de terceiros, assim você pode integrar o seu script juntamente com
o build do Node.js.

### Instruções para linux

O primeiro passo é instalar as dependências e baixar o source code do Node.js
para que possamos compilá-lo.

```bash
sudo apt-get install build-essential
curl -O http://nodejs.org/dist/v0.10.35/node-v0.10.35.tar.gz
tar -zxvf node-v0.10.35.tar.gz
cd node-v0.10.35
```

Feito isso, precisamos criar um arquivo chamado `_third_party_main.js` e
adicionar este arquivo ao `node.gyp`, depois disto é só compilar.

```bash
# Criamos o arquivo necessário
echo 'console.log("Hello world!");' >> lib/_third_party_main.js

# Depois acrescentamos este arquivo nas dependências da build
sed -i "s/lib\/zlib.js',/lib\/zlib.js',\n'lib\/_third_party_main.js'/" node.gyp

# Agora é só compilar o Node.js!
./configure
make
```

Após a compilação seu binário estará localizado na pasta `./out/Release` e você
já pode rodar ele.

```bash
cd ./out/Release
./node
```

Agora é só enviar este executável para os seus amigos, o seu programa rodará
sem precisar instalar o Node.js.

### Instruções para Windows

Se alguém souber o processo de compilação para Windows, por favor
[forke esta postagem][0] e adicione aqui.

### Bônus: reduzindo o tamanho com o UPX

O [UPX][1] é um packer para executáveis, reduzindo o tamanho dos mesmo, podemos
utilizar ele para reduzir o tamanho do executável gerado.

```bash
sudo apt-get install upx
cd ./out/Release
cp node node_compressed
upx node_compressed
```

Podemos ver que o resultado ficou muito bom, nosso executável passou de 12Mb
para apenas 4Mb, e continua funcionando.

```
➜  Release ls -lah
total 43M
-rwxrwxr-x  1 alan alan  12M Jan 12 15:31 node*
-rwxrwxr-x  1 alan alan 4,1M Jan 12 15:36 node_compressed*
```

[0]: https://github.com/alanhoff/alanhoff.com/tree/master/content/posts
[1]: http://upx.sourceforge.net/
]]></description><guid isPermaLink="false">Criando executáveis com Node.js</guid><dc:creator><![CDATA[Alan Hoffmeister]]></dc:creator><pubDate>Mon, 12 Jan 2015 16:29:00 GMT</pubDate></item><item><title><![CDATA[Não jogue lixo no npm!]]></title><description><![CDATA[
Sim, tudo o que está dentro do seu projeto é empacotado na hora de publicar o
seu pacote no npm, incluindo seus testes, documentação, imagens, descrição da
API e possíveis pornografias. Se o npm começar a ficar lento, a culpa é sua!
<!--more-->

### Os arquivos que o npm NÃO precisa

Pense um pouco comigo, toda vez que eu utilizo o `require('seu-modulo-lindo')`
estou usando a documentação do seu módulo? Estou usando os testes dele? Ou pior
ainda: estou usando o ***WEBSITE DO PROJETO*** (sim uma vez vi um tarball com o
gh-pages do projeto, e não era meu)? Obviamente você não precisa destes itens.
Então porque deixar esses arquivos na hora de rodar o `npm publish`?

Se eu quero realizar os testes do seu projeto, vou fazer o fork do mesmo,
instalar as dependências de desenvolvimento e rodar o comando de testes. Eu ***
não vou*** baixar o tarball do npm para fazer isso, muito menos para ler a
documentação.

Pode parecer besteira para alguns, mas se enviássemos somente os arquivos
necessários para um ambiente de produção, a instalação dos nossos projetos
iria demorar menos, iríamos consumir menos banda, o cache local dos pacotes
também diminuiria. Dica: fale com o seu chefe sobre redução de gastos.

### Os arquivos que o npm precisa

Lembre-se destes três arquivos: `package.json`, `readme.md` e `license`.
Obviamente você também vai precisar de todos os arquivos necessários para seu
módulo rodar quando o outro cara fizer o `require` ou compilar binários na hora
da instalação.

* __`package.json`__, acho que não precisa dar explicação, sem isso nem da para
publicar.
* __`readme.md`,__ além de servir para formatar a página do seu módulo no npm,
também é muito útil quando precisamos consular rapidamente algo utilizando o
`npm show modulo-lindo readme`.
* __`license`__ é sempre necessário se você quiser deixar seu pacote dentro das
normas da sua licença.

### O .npmignore salvando você

A primeira opção é utilizar o `.gitignore`, tudo o que está ali dentro o npm irá
ignorar na hora de publicar, mas também vai dar trabalho na hora do `git push`
pois certamente você vai querer mandar a documentação e os testes para o seu
repositório, para solucionar isso você pode utilizar o `.npmignore`, que
funciona exatamente igual ao `.gitignore` porém ele só é lido pelo npm na hora
de publicar um módulo. E aqui vai uma colinha pra você não precisar adicionar
arquivo por aquivo dentro do seu `.npmignore`

```
# Primeiro ignoramos tudo
*
# Agora permitimos somente os arquivos necessários
!package.json
!readme.md
!license
!lib/
```

Pronto, após seguir esses simples passos, você já estará capacitado a parar de
ferrar com o npm.
]]></description><guid isPermaLink="false">Não jogue lixo no npm!</guid><dc:creator><![CDATA[Alan Hoffmeister]]></dc:creator><pubDate>Wed, 22 Oct 2014 01:00:00 GMT</pubDate></item><item><title><![CDATA[Renderizando com dust.js no Express]]></title><description><![CDATA[
Uma das coisas mais básicas que um sistema web pode fazer é renderizar uma
página HTML para ser exibida no navegador do seu usuário. Embora essa seja
uma tarefa trivial, muitos recém chegados podem ter uma certa dificuldade de
achar a melhor ferramenta de renderização para o seu projeto.<!--more--> Hoje
vamos falar sobre uma delas, o [dust.js][0], em especial o
[fork criado pela LinkedIn][1].

### Um pouco sobre o dust.js

O dust.js foi desenvolvido originalmente por [Aleksander Williams][2], este
módulo se destaca dos [demais templates engines][3] por ser assíncrono por
natureza e stream do template para o cliente enquanto ainda está sendo gerado.
Por exemplo, com esse helper abaixo, consigo demonstrar a natureza assíncrona
deste template engine.

```javascript
dust.makeBase({
    asyncHello : function(chunk){
        // Informamos que o processo é assíncrono
        chunk.map(function(chunk){

            // Depois de um segundo escrevemos uma frase
            // no chunk que recebemos
            setTimeout(function(){
                chunk.write('Hello async world!');

                // Precisamos informar que terminamos
                // nossas operações assíncronas e o dust.js
                // pode seguir seu trabalho
                chunk.end();
            }, 1000);
        });
    }
});
```

Com nosso helper registrado so é necessário chamá-lo no seu template:

```html
<h1>{asyncHello}</h1>

<!-- Será renderizado para -->
<h1>Hello async world!</h1>
```

Com isso podemos deixar o carregamento de dados dinâmico, sem precisar carregar
todos os dados na rota antes de chamar a renderização, assim podemos ter
templates dinâmicos que não dependem da rota para carregar determinada
informação. Quem já trabalha com server side templates no Node.js sabe muito
bem o problema que muitas vezes isso pode causar.

### Express e Adaro

Esse post terá o [Express][4] como gerenciador de rotas da nossa aplicação e o
pacote [Adaro][7] que ajudará a plugar o Dust.js no Express. O pacote
[request][5] servirá como uma ajuda na hora de construir o helper `gists`,
responsável por listar gists de um determinado usuário.

Começaremos criando um diretório e instalando os pacotes necessários:

```bash
mkdir teste-dust
cd teste-dust
mkdir template
npm init
# Respoder as perguntas
npm install --save express adaro dustjs-helpers dustjs-linkedin request
```

Com a nossa pasta pronta, já podemos começar o código:

```javascript
// Começamos com o require dos pacotes importantes
// para o projeto
var request = require('request');
var express = require('express');
var app = express();
var dustjs = require('adaro');

// Setando opções padrões para o request
var r = request.defaults({
    headers: {
        'User-Agent': 'Node.js'
    }
});

// Usando a api do Express, cadastramos uma nova engine
// e desabilitamos o cache pois estamos em modo de desenvolvimento
app.engine('dust', dustjs.dust({
    cache: false
}));

// Setamos algumas variáveis, como a engine responsável
// por renderizar, desabilitamos o cache do Express e
// setamos o diretório onde estão guardadas nossas views
app.set('view engine', 'dust');
app.set('view cache', 'false');
app.set('views', __dirname + '/template');

// Setamos a nossa primeira rota, onde renderizamos
// o index.dust e passamos algumas variáveis para o template
app.get('/', function(req, res){
    res.render('index', {
        pessoas: [
            {nome: 'Alan', sobrenome: 'Hoffmeister'},
            {nome: 'John', sobrenome: 'Levitt'},
            {nome: 'Lorem', sobrenome: 'Ipsum'}
        ],
        gists: function(chunk, context, bodies, params){

            // Estamos dizendo que esse chunk, ou parte do
            // template que está usando o #gists, é assíncrono
            return chunk.map(function(chunk){
                var url = 'https://api.github.com/users/' +
                    params.user + '/gists';

                // Vamos buscar na API do GitHub os últimos
                // gists do usuário que foi configurado no
                // tag do template
                r.get(url, function(err, headers, body){
                    var json = JSON.parse(body);

                    // Para cada gist encontrado, temos que renderizar
                    // o bloco, enviarmos o gist como o contexto do bloco,
                    // assim poder usar o json do gist como marcação no
                    // template
                    json.forEach(function(repo){
                        chunk.render(bodies.block, context.push(repo));
                    });

                    chunk.end();
                });
            });
        }
    });
});

// Uma segunda rota onde vamos renderizar a nossa pseudo página
// de contato
app.get('/contato', function(req, res){
    res.render('contato');
});

// Essa rota será acionada sempre que o Express detectar uma
// requisição que está pedidindo por uma rota não cadastrada,
// nessa caso específico usaremos para detectar páginas que não
// existem.
app.all('*', function(req, res){
    res.status(404).render('404');
});

// Iniciamos o Express na porta 8080
app.listen(8080);
```

### Templates

Os templates estão disponíveis [neste repositório][6] dentro da pasta
`template`, tudo o que você precisa fazer é copiar os arquivos para a pasta que
criamos anteriormente. Não vou postar aqui pois o intuito desta postagem não é
demonstrar o markup do Dust.js mas sim suas facilidades e integração.

### Conclusão

Escrever um helper para o Dust.js pode não ser a coisa mais fácil do mundo,
pois a natureza da própria plataforma Node.js anceia por métodos assíncronos, e
são esses métodos que tornam essa template engine extremamente performática e
modular, perfeita para o seu próximo projeto em Node.js.

[0]: https://linkedin.github.io/dustjs
[1]: http://engineering.linkedin.com/frontend/client-side-templating-throwdown-mustache-handlebars-dustjs-and-more
[2]: https://github.com/akdubya
[3]: http://node-modules.com/search?q=template
[4]: http://expressjs.com
[5]: https://github.com/mikeal/request
[6]: https://github.com/alanhoff/alanhoff.com-dust
[7]: https://github.com/krakenjs/adaro
]]></description><guid isPermaLink="false">Renderizando com dust.js no Express</guid><dc:creator><![CDATA[Alan Hoffmeister]]></dc:creator><pubDate>Wed, 22 Oct 2014 00:00:00 GMT</pubDate></item></channel></rss>